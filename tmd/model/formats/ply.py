"""
PLY exporter implementation for TMD.

This module provides the PLYExporter class and related functions for exporting
height maps to PLY files, which are commonly used for storing 3D scanned data.
"""

import os
import numpy as np
import logging
import struct
from typing import Optional, List, Dict, Any, Tuple, Union

from ..base import ModelExporter, ExportConfig, MeshData
from ..utils import validate_heightmap, ensure_directory_exists
from ..registry import register_exporter

# Set up logging
logger = logging.getLogger(__name__)


@register_exporter
class PLYExporter(ModelExporter):
    """Exporter for PLY format."""
    
    # Class attributes
    format_name = "ply"  # Use lowercase for consistent format name matching
    file_extensions = ["ply"]
    binary_supported = True
    
    @classmethod
    def export(cls, 
               height_map: np.ndarray, 
               filename: str, 
               config: ExportConfig) -> Optional[str]:
        """
        Export a heightmap to PLY format.
        
        Args:
            height_map: 2D numpy array of height values
            filename: Output filename
            config: Export configuration
            
        Returns:
            Path to the created file if successful, None otherwise
        """
        # Validate input
        if not validate_heightmap(height_map):
            logger.error("Invalid height map: empty, None, or too small")
            return None

        # Ensure filename has correct extension
        filename = cls.ensure_extension(filename)
            
        # Ensure output directory exists
        if not ensure_directory_exists(filename):
            return None

        try:
            # Create mesh from heightmap
            mesh = cls.create_mesh_from_heightmap(height_map, config)
            
            # Ensure we have normals if needed
            mesh.ensure_normals()
            
            # Write PLY file based on binary flag
            binary = config.binary if config.binary is not None else True
            if binary:
                write_binary_ply(mesh, filename)
            else:
                write_ascii_ply(mesh, filename)
            
            return filename
            
        except Exception as e:
            logger.error(f"Error exporting to PLY: {e}")
            import traceback
            traceback.print_exc()
            return None


def write_binary_ply(mesh: MeshData, filename: str) -> None:
    """
    Write mesh data to binary PLY file.
    
    Args:
        mesh: MeshData object containing the mesh to export
        filename: Output filename
    """
    import struct
    
    vertex_count = len(mesh.vertices)
    face_count = len(mesh.faces)

    with open(filename, 'wb') as f:
        # Write header in ASCII
        header = [
            "ply\n",
            "format binary_little_endian 1.0\n",
            "comment Generated by TMD Exporter\n",
            f"element vertex {vertex_count}\n",
            "property float x\n",
            "property float y\n",
            "property float z\n"
        ]
        
        if mesh.normals is not None:
            header.extend([
                "property float nx\n",
                "property float ny\n",
                "property float nz\n"
            ])
            
        header.extend([
            f"element face {face_count}\n",
            "property list uchar int vertex_indices\n",
            "end_header\n"
        ])
        
        f.write(''.join(header).encode('ascii'))

        # Write vertices
        for i in range(vertex_count):
            f.write(struct.pack('<fff', *mesh.vertices[i]))
            if mesh.normals is not None:
                f.write(struct.pack('<fff', *mesh.normals[i]))

        # Write faces
        for face in mesh.faces:
            f.write(struct.pack('<B', 3))  # Number of vertices in face
            f.write(struct.pack('<III', *face))


def write_ascii_ply(mesh: MeshData, filename: str) -> None:
    """
    Write mesh data to ASCII PLY file.
    
    Args:
        mesh: MeshData object containing the mesh to export
        filename: Output filename
    """
    vertex_count = len(mesh.vertices)
    face_count = len(mesh.faces)

    with open(filename, 'w') as f:
        # Write header
        f.write("ply\n")
        f.write("format ascii 1.0\n")
        f.write("comment Generated by TMD Exporter\n")
        f.write(f"element vertex {vertex_count}\n")
        f.write("property float x\n")
        f.write("property float y\n")
        f.write("property float z\n")
        
        if mesh.normals is not None:
            f.write("property float nx\n")
            f.write("property float ny\n")
            f.write("property float nz\n")
            
        f.write(f"element face {face_count}\n")
        f.write("property list uchar int vertex_indices\n")
        f.write("end_header\n")

        # Write vertices
        for i in range(vertex_count):
            line = f"{mesh.vertices[i][0]} {mesh.vertices[i][1]} {mesh.vertices[i][2]}"
            if mesh.normals is not None:
                line += f" {mesh.normals[i][0]} {mesh.normals[i][1]} {mesh.normals[i][2]}"
            f.write(line + "\n")

        # Write faces
        for face in mesh.faces:
            f.write(f"3 {face[0]} {face[1]} {face[2]}\n")


def _generate_vertex_colors(
    vertices: np.ndarray,
    height_map: np.ndarray,
    color_map: str = 'terrain'
) -> np.ndarray:
    """
    Generate vertex colors based on height values.
    
    Args:
        vertices: Nx3 numpy array of vertex positions
        height_map: 2D height map array (used to determine overall height range)
        color_map: Name of the colormap to use
        
    Returns:
        Nx3 numpy array of RGB colors (0-255)
    """
    try:
        from matplotlib import cm

        # Compute the height range from the Z-coordinate of vertices
        z_min = np.min(vertices[:, 2])
        z_max = np.max(vertices[:, 2])
        z_range = z_max - z_min if z_max - z_min > 1e-10 else 1.0

        # Normalize Z values to the range [0, 1]
        normalized_z = (vertices[:, 2] - z_min) / z_range

        # Apply the colormap to obtain RGBA values, then convert to 8-bit RGB
        cmap = cm.get_cmap(color_map)
        rgba_colors = cmap(normalized_z)
        rgb_colors = (rgba_colors[:, :3] * 255).astype(np.uint8)

        return rgb_colors
    except ImportError as e:
        logger.warning(f"Matplotlib not available, using grayscale colors: {e}")
        # Fallback: generate grayscale colors based on height
        z_min = np.min(vertices[:, 2])
        z_max = np.max(vertices[:, 2])
        z_range = max(z_max - z_min, 1e-10)
        normalized_z = (vertices[:, 2] - z_min) / z_range
        grayscale = (normalized_z * 255).astype(np.uint8)
        rgb_colors = np.column_stack([grayscale, grayscale, grayscale])
        return rgb_colors