""".

Shader export functions for TMD height maps.

This module provides functions to export height maps to shader formats
for use in real-time 3D graphics applications.
"""

import os
import numpy as np
from PIL import Image


def export_heightmap_to_fragment_shader(
    height_map,
    output_file,  # Changed from filename to output_file to match test expectations
    shader_language="glsl",
    scale=1.0,  # Added to match test expectations
    texture_size=None,
    heightmap_variable="heightMap",
    normalize=True,
    include_texture=True,  # Changed from export_texture to include_texture
    texture_filename=None,
    template=None  # Added template parameter
):
    """.

    Export a height map as a fragment shader for use in real-time graphics applications.
    
    Args:
        height_map: 2D numpy array of height values.
        output_file: Output filename for the shader.
        shader_language: Shader language to use ('glsl', 'hlsl', or 'wgsl').
        scale: Height scaling factor.
        texture_size: Optional tuple (width, height) to resize the height map. 
                     If None, uses the original dimensions.
        heightmap_variable: Variable name used in the shader.
        normalize: If True, normalizes height values to 0-1 range.
        include_texture: If True, also exports a texture image.
        texture_filename: Optional filename for texture. If None, derives from shader filename.
        template: Optional custom shader template string.
        
    Returns:
        Tuple of (shader_path, texture_path or None)
        
    Raises:
        ValueError: If the shader language is not supported.
    """
    # Validate shader language
    supported_languages = ["glsl", "hlsl", "wgsl"]
    if shader_language.lower() not in supported_languages:
        raise ValueError(f"Unsupported shader language: {shader_language}")
    
    try:
        # Ensure directory exists
        os.makedirs(os.path.dirname(os.path.abspath(output_file)), exist_ok=True)
        
        # Normalize height map if requested
        if normalize:
            min_val = np.min(height_map)
            max_val = np.max(height_map)
            if max_val > min_val:
                height_map_norm = (height_map - min_val) / (max_val - min_val)
            else:
                height_map_norm = height_map - min_val
        else:
            height_map_norm = height_map
        
        # Resize height map if requested
        if texture_size:
            height_map_norm = np.array(Image.fromarray(height_map_norm).resize(texture_size, Image.Resampling.LANCZOS))
        
        # Get height map dimensions for the shader
        height, width = height_map_norm.shape
        
        # Generate texture filename if including a texture
        if include_texture:
            if not texture_filename:
                texture_filename = os.path.splitext(output_file)[0] + "_texture.png"
            
            # Save the height map as a grayscale image
            img_array = (height_map_norm * 255).astype(np.uint8)
            Image.fromarray(img_array).save(texture_filename)
            print(f"Height map texture saved to {texture_filename}")
        else:
            texture_filename = None
        
        # If custom template is provided, use it
        if template:
            shader_code = template
            # Replace placeholders in template
            shader_code = shader_code.replace("{{SCALE}}", f"{scale:.6f}")
            shader_code = shader_code.replace("{{TEXTURE_FILENAME}}", texture_filename or "")
            shader_code = shader_code.replace("{{HEIGHTMAP_VARIABLE}}", heightmap_variable)
        else:
            # Generate appropriate shader code based on language
            if shader_language.lower() == "glsl":
                shader_code = _generate_glsl_shader(height_map_norm, texture_filename, scale)
            elif shader_language.lower() == "hlsl":
                shader_code = _generate_hlsl_shader(height_map_norm, texture_filename, scale)
            elif shader_language.lower() == "wgsl":
                shader_code = _generate_wgsl_shader(height_map_norm, texture_filename, scale)
        
        # Write shader to file
        with open(output_file, "w") as f:
            f.write(shader_code)
        
        print(f"Fragment shader exported to {output_file}")
        return output_file, texture_filename
        
    except Exception as e:
        print(f"Error exporting fragment shader: {e}")
        import traceback
        traceback.print_exc()
        return None, None


def _generate_glsl_shader(height_map, texture_filename, scale=1.0):
    """Generate GLSL fragment shader code for the height map.."""
    # Extract the texture filename without path
    texture_basename = os.path.basename(texture_filename) if texture_filename else None
    
    # Default GLSL shader template
    shader_code = """// Height Map Fragment Shader.

// Generated by TMD Toolkit

#version 330 core

in vec2 TexCoords;
out vec4 FragColor;

"""

    if texture_filename:
        shader_code += f""".

uniform sampler2D heightMap; // Load from "{texture_basename}"
uniform float heightScale = {scale:.6f};

void main()
{{
    // Sample height map
    float height = texture(heightMap, TexCoords).r * heightScale;
    
    // Calculate normal based on height gradient
    vec2 texelSize = 1.0 / textureSize(heightMap, 0);
    float left = texture(heightMap, TexCoords - vec2(texelSize.x, 0.0)).r * heightScale;
    float right = texture(heightMap, TexCoords + vec2(texelSize.x, 0.0)).r * heightScale;
    float up = texture(heightMap, TexCoords - vec2(0.0, texelSize.y)).r * heightScale;
    float down = texture(heightMap, TexCoords + vec2(0.0, texelSize.y)).r * heightScale;
    
    vec3 normal = normalize(vec3(
        left - right,
        up - down,
        2.0
    ));
    
    // Visualize height or normal
    // Option 1: Visualize height
    // FragColor = vec4(vec3(height), 1.0);
    
    // Option 2: Visualize normal
    FragColor = vec4(normal * 0.5 + 0.5, 1.0);
    
    // Add shading based on normal
    vec3 lightDir = normalize(vec3(1.0, 1.0, 2.0));
    float diffuse = max(dot(normal, lightDir), 0.0);
    vec3 color = vec3(0.2, 0.5, 0.7) * (diffuse * 0.7 + 0.3);
    FragColor = vec4(color, 1.0);
}}
"""
    else:
        # If no texture, encode height data directly in the shader
        # For small height maps only - will produce very large shaders for big maps
        height, width = height_map.shape
        shader_code += f""".

uniform float heightScale = {scale:.6f};

// Height map dimensions: {width}x{height}
// Height map encoded directly in shader (optimized for small maps)

float getHeight(vec2 uv) {{
    // Convert texture coordinates to pixel coordinates
    int x = int(uv.x * {width-1}.0);
    int y = int(uv.y * {height-1}.0);
    
    // Clamp to valid range
    x = clamp(x, 0, {width-1});
    y = clamp(y, 0, {height-1});
    
    // Lookup height from encoded data
    float height = 0.0;
    
    // Height map data array
    // Encode only a subset of points for performance - max 32x32 grid
    const int gridSize = {min(32, min(width, height))};
    const float heights[gridSize * gridSize] = float[](
"""
        # Sample the height map to create a smaller grid
        sample_height = height_map
        if width > 32 or height > 32:
            # Downsample to max 32x32 grid
            sample_y = np.linspace(0, height-1, min(32, height), dtype=int)
            sample_x = np.linspace(0, width-1, min(32, width), dtype=int)
            sample_height = height_map[np.ix_(sample_y, sample_x)]
        
        # Add height values
        values = []
        for row in sample_height.flatten():
            values.append(f"{row:.6f}")
        
        shader_code += "        " + ",\n        ".join(values) + "\n    );\n"
            
        shader_code += """.

    // Calculate index in the height grid
    int grid_width = int(sqrt(float(heights.length())));
    int grid_x = int(uv.x * float(grid_width - 1));
    int grid_y = int(uv.y * float(grid_width - 1));
    int index = grid_y * grid_width + grid_x;
    
    return heights[index] * heightScale;
}

void main()
{
    // Calculate height at this fragment
    float height = getHeight(TexCoords);
    
    // Calculate approximate normal
    float eps = 0.01;
    float left = getHeight(TexCoords - vec2(eps, 0.0));
    float right = getHeight(TexCoords + vec2(eps, 0.0));
    float up = getHeight(TexCoords - vec2(0.0, eps));
    float down = getHeight(TexCoords + vec2(0.0, eps));
    
    vec3 normal = normalize(vec3(
        left - right,
        up - down,
        2.0 * eps
    ));
    
    // Add lighting based on normal
    vec3 lightDir = normalize(vec3(1.0, 1.0, 2.0));
    float diffuse = max(dot(normal, lightDir), 0.0);
    vec3 color = vec3(0.2, 0.5, 0.7) * (diffuse * 0.7 + 0.3);
    FragColor = vec4(color, 1.0);
}
"""
    
    return shader_code


def _generate_hlsl_shader(height_map, texture_filename, scale=1.0):
    """Generate HLSL fragment shader code for the height map.."""
    # Extract the texture filename without path
    texture_basename = os.path.basename(texture_filename) if texture_filename else None
    
    # Default HLSL shader template
    shader_code = """// Height Map Pixel Shader (HLSL).

// Generated by TMD Toolkit

"""

    if texture_filename:
        shader_code += f""".

Texture2D heightMap; // Load from "{texture_basename}"
SamplerState samLinear;

cbuffer Constants : register(b0)
{{
    float heightScale;
}};

struct PS_INPUT
{{
    float2 texCoord : TEXCOORD0;
}};

struct PS_OUTPUT
{{
    float4 color : SV_Target;
}};

PS_OUTPUT main(PS_INPUT input)
{{
    PS_OUTPUT output;
    float2 texCoords = input.texCoord;
    
    // Sample height map
    float height = heightMap.Sample(samLinear, texCoords).r * heightScale;
    
    // Calculate normal based on height gradient
    float2 texelSize;
    heightMap.GetDimensions(texelSize.x, texelSize.y);
    texelSize = 1.0 / texelSize;
    
    float left = heightMap.Sample(samLinear, texCoords - float2(texelSize.x, 0.0)).r * heightScale;
    float right = heightMap.Sample(samLinear, texCoords + float2(texelSize.x, 0.0)).r * heightScale;
    float up = heightMap.Sample(samLinear, texCoords - float2(0.0, texelSize.y)).r * heightScale;
    float down = heightMap.Sample(samLinear, texCoords + float2(0.0, texelSize.y)).r * heightScale;
    
    float3 normal = normalize(float3(
        left - right,
        up - down,
        2.0
    ));
    
    // Add lighting based on normal
    float3 lightDir = normalize(float3(1.0, 1.0, 2.0));
    float diffuse = max(dot(normal, lightDir), 0.0);
    float3 color = float3(0.2, 0.5, 0.7) * (diffuse * 0.7 + 0.3);
    
    output.color = float4(color, 1.0);
    return output;
}}
"""
    else:
        # Simplified version without texture
        shader_code += f""".

// Height map dimensions: {height_map.shape[1]}x{height_map.shape[0]}
// Simplified version without texture

cbuffer Constants : register(b0)
{{
    float heightScale;
}};

struct PS_INPUT
{{
    float2 texCoord : TEXCOORD0;
}};

struct PS_OUTPUT
{{
    float4 color : SV_Target;
}};

PS_OUTPUT main(PS_INPUT input)
{{
    PS_OUTPUT output;
    float2 texCoords = input.texCoord;
    
    // Simple procedural height in this version
    float height = heightScale * (
        sin(texCoords.x * 10.0) * 
        cos(texCoords.y * 10.0) * 0.5 + 0.5
    );
    
    // Basic shading
    float3 color = float3(height, height, height);
    output.color = float4(color, 1.0);
    return output;
}}
"""
    
    return shader_code


def _generate_wgsl_shader(height_map, texture_filename, scale=1.0):
    """Generate WGSL shader code for the height map (WebGPU).."""
    # Extract the texture filename without path
    texture_basename = os.path.basename(texture_filename) if texture_filename else None
    
    # Default WGSL shader template
    shader_code = """// Height Map Shader (WGSL for WebGPU).

// Generated by TMD Toolkit

"""

    if texture_filename:
        shader_code += f""".

struct VertexOutput {{
    @builtin(position) position: vec4f,
    @location(0) texCoord: vec2f,
}};

@group(0) @binding(0) var heightMapSampler: sampler;
@group(0) @binding(1) var heightMap: texture_2d<f32>; // Load from "{texture_basename}"

@fragment
fn main(input: VertexOutput) -> @location(0) vec4f {{
    let texCoords = input.texCoord;
    
    // Sample height map
    let height = textureSample(heightMap, heightMapSampler, texCoords).r * {scale:.6f};
    
    // Calculate normal based on height gradient
    let texelSize = vec2f(1.0) / vec2f(textureDimensions(heightMap));
    let left = textureSample(heightMap, heightMapSampler, texCoords - vec2f(texelSize.x, 0.0)).r * {scale:.6f};
    let right = textureSample(heightMap, heightMapSampler, texCoords + vec2f(texelSize.x, 0.0)).r * {scale:.6f};
    let up = textureSample(heightMap, heightMapSampler, texCoords - vec2f(0.0, texelSize.y)).r * {scale:.6f};
    let down = textureSample(heightMap, heightMapSampler, texCoords + vec2f(0.0, texelSize.y)).r * {scale:.6f};
    
    let normal = normalize(vec3f(
        left - right,
        up - down,
        2.0
    ));
    
    // Add lighting based on normal
    let lightDir = normalize(vec3f(1.0, 1.0, 2.0));
    let diffuse = max(dot(normal, lightDir), 0.0);
    let color = vec3f(0.2, 0.5, 0.7) * (diffuse * 0.7 + 0.3);
    
    return vec4f(color, 1.0);
}}
"""
    else:
        # Simplified version without texture
        shader_code += f""".

struct VertexOutput {{
    @builtin(position) position: vec4f,
    @location(0) texCoord: vec2f,
}};

@fragment
fn main(input: VertexOutput) -> @location(0) vec4f {{
    let texCoords = input.texCoord;
    
    // Simple procedural height in this version
    let height = {scale:.6f} * (
        sin(texCoords.x * 10.0) * 
        cos(texCoords.y * 10.0) * 0.5 + 0.5
    );
    
    // Basic shading
    let color = vec3f(height, height, height);
    return vec4f(color, 1.0);
}}
"""
    
    return shader_code


def export_heightmap_to_shader_pack(
    height_map,
    output_dir,
    base_name="heightmap",
    include_texture=True,
    scale=1.0,
    texture_size=1024,
    normalize=True
):
    """.

    Export a height map to multiple shader formats in a single package.
    
    Args:
        height_map: 2D numpy array of height values
        output_dir: Directory to store shader files
        base_name: Base filename for the shaders
        include_texture: Whether to include a texture export
        scale: Height scaling factor
        texture_size: Size to resize the texture (max dimension)
        normalize: Whether to normalize height values to [0,1]
    
    Returns:
        dict: Paths to the created shader files
    """
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Export shaders in different formats
    result = {}
    
    # GLSL shader
    glsl_file = os.path.join(output_dir, f"{base_name}.glsl")
    result['glsl'], texture_file = export_heightmap_to_fragment_shader(
        height_map, 
        output_file=glsl_file, 
        shader_language="glsl",
        scale=scale,
        include_texture=include_texture,
        normalize=normalize
    )
    
    # HLSL shader
    hlsl_file = os.path.join(output_dir, f"{base_name}.hlsl")
    result['hlsl'], _ = export_heightmap_to_fragment_shader(
        height_map, 
        output_file=hlsl_file, 
        shader_language="hlsl",
        scale=scale,
        include_texture=include_texture,
        normalize=normalize,
        texture_filename=texture_file  # Reuse the texture from GLSL
    )
    
    # WGSL shader
    wgsl_file = os.path.join(output_dir, f"{base_name}.wgsl")
    result['wgsl'], _ = export_heightmap_to_fragment_shader(
        height_map, 
        output_file=wgsl_file, 
        shader_language="wgsl",
        scale=scale,
        include_texture=include_texture,
        normalize=normalize,
        texture_filename=texture_file  # Reuse the texture from GLSL
    )
    
    # Add the texture file to the result
    if include_texture and texture_file:
        result['texture'] = texture_file
    
    # Create a README file with usage instructions
    readme_file = os.path.join(output_dir, "README.md")
    with open(readme_file, "w") as f:
        f.write(f"""# Height Map Shader Pack.

This package contains shader implementations of the height map for different graphics APIs.

## Contents

- `{base_name}.glsl`: OpenGL/WebGL fragment shader
- `{base_name}.hlsl`: DirectX/Unity pixel shader
- `{base_name}.wgsl`: WebGPU shader
{f"- `{os.path.basename(texture_file)}`: Height map texture (grayscale)" if include_texture and texture_file else ""}

## Usage

### OpenGL/WebGL

```glsl
// In your vertex shader, pass texture coordinates
varying vec2 TexCoords;

// In your fragment shader
uniform sampler2D heightMap;
uniform float heightScale = {scale:.6f};

// Then include the content of {base_name}.glsl
```

### DirectX/Unity

```hlsl
// Create a texture parameter in your material
Texture2D _HeightMap;
float _HeightScale = {scale:.6f};

// Then include the content of {base_name}.hlsl
```

### WebGPU

```js
// Load the texture
const heightMapTexture = device.createTexture({{
  size: [width, height],  // Use your texture dimensions here
  format: 'r8unorm',
  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
}});

// Create bind group
const bindGroup = device.createBindGroup({{
  layout: pipeline.getBindGroupLayout(0),
  entries: [
    {{
      binding: 0,
      resource: sampler
    }},
    {{
      binding: 1,
      resource: heightMapTexture.createView()
    }}
  ]
}});

// Then use the shader from {base_name}.wgsl
```

## Advanced

These shaders provide a starting point for using the height map in real-time 3D applications.
You can modify them to implement custom effects like displacement mapping, normal mapping,
or procedural animation.
""")
    
    result['readme'] = readme_file
    print(f"Shader pack exported to {output_dir}")
    
    return result
